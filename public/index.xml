<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nicong的生活学习笔记</title>
    <link>/</link>
    <description>Recent content on Nicong的生活学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 01 Aug 2022 09:34:30 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《浪潮之巅》读书笔记 -- 硅谷奇迹探秘</title>
      <link>/posts/why_silicon_vally_success/</link>
      <pubDate>Mon, 01 Aug 2022 09:34:30 +0800</pubDate>
      
      <guid>/posts/why_silicon_vally_success/</guid>
      <description>在过去60多年里，硅谷从类似蛮荒之地发展起来，实现了可持续增长，并且在历次产业转型中都没有落伍，还在不断引领世界科技产业的潮流，实属奇迹。
​	&amp;mdash;&amp;mdash;《浪潮之巅 - 硅谷奇迹探秘》
究竟是什么原因使得硅谷能成为世界科技之都？
宛若似真的理由 媒体上常见的一些对硅谷的解读。
气候说 很多人把硅谷的成功归咎于其舒适宜人的地中海气候。
舒适的气候确实容易吸引人才留下，但未必能构成硅谷成功的原因。在欧洲也有不少拥有地中海气候的国家和地区，例如希腊、意大利、西班牙等等，但它们恰恰是欧元区中经济和社会发展落后的地区，而地处高寒地区的德国却发展得不错。
硅谷的成功即使和气候有关，也不是决定因素。
斯坦福之说 斯坦福是另一个让不少人认为硅谷成功的原因，因为它源源不断地向硅谷输送技术和人才。
不过，斯坦福的成功和硅谷的成功虽然有相关性，但不是因果关系。反倒是硅谷的成功为斯坦福带来了成功。
世界上很多一流大学的周边也没有出现像硅谷这样的科技繁荣地区，例如拥有哈佛大学和麻省理工的波士顿。同样，创业活跃的地区也不一定拥有一流大学，例如以色列的特拉维夫和中国的深圳。
重视知识产权说 硅谷公司拥有的专利数量在美国公司乃至全世界的公司中，都算不上出色。普遍任务创新力不错的苹果公司、Facebook、特斯拉，获得美国专利的数量都排不进前十名。
所以不能直接用专利数量来衡量一家公司的创新力。
风险投资说 风投只是创业的催化剂，不能天真地认为有风投就能复制硅谷的成功。
现在，中国一线城市一年的风投金额早已超过硅谷，虽然有不少优秀的创业公司，不过更多的是资本的泡沫和烧钱，并未涌现更多新技术。
综上所述，不难看到，学习硅谷的经验，只流于表面，学一些皮毛，对实际工作不会有什么帮助。
下面换一个角度来看看硅谷的特别之处。
成王败寇 硅谷地区很多收入不低的人买不起房子，甚至租不起房子，不得不离开硅谷。经常有媒体以此唱衰硅谷，但硅谷却不曾衰落。事实上，硅谷不是一个可以照顾创业者的孵化器，而是一个成王败寇的地方。
在硅谷，发生过不少年轻人通过在科技领域的发明创造在“一夜间”获得百万甚至亿万财富的奇迹故事，例如乔布斯、比尔盖茨、拉里佩奇等等。他们也成为了世界范围内无数年轻人的榜样。梦想着能在大学期间与朋友发明一个新的概念，然后创立公司，获得上千万投资，一夜之前成功	千万富翁，走上人生巅峰。但实际上这种事情发生的概率不比中六合彩大奖高多少。
很多对硅谷趋之若鹜、沉溺于创业梦想的人都没有意识到硅谷的竞争有多残酷，成功几率有多低。在硅谷过去20年的时间内，每年有大概 3000～4000 家公司获得投资，但是能成功上市的不到 1%，融不到钱的公司就更多了。除了上市，还能被收购。但是大多数并购对于创业者来说只不过是拿回创业期间的工资，并不能在硅谷享受良好的生活。
要想创业成功，必须同时具备很多因素。
小而精的创始团队。能熬得住寂寞，并且精力过人，能承受每天工作十几个小时的工作时长；还要是多面手，能承担各种各样的事情；在技术上还要有自己的过人之处。 要有商业头脑，并且必须要有能盈利的商业模式。 要有超强的判断力和执行力，能不断适应环境的变化。不幸的是，判断力和执行力很大程度来自于经验和见识，不是一般的培训就能得到的。 适合的时机以及运气。 即使具备了上述的条件，付出了巨大的努力，成功上市了，也不见得就能发财。那些能成功做大做强的公司不少都有过九死一生的经历，成败往往就在一线之间。
当人们羡慕苹果、Google、英特尔和思科的成功，津津乐道讲述它们的传奇故事时，也应该清楚那是以无数失败者做分母为代价的。&amp;hellip;&amp;hellip;那些光鲜亮丽的公司的背后是无数工程师、产品经理和行政人员付出的血和汗。
​	&amp;mdash;&amp;mdash;《浪潮之巅 - 硅谷奇迹探秘》
嗜血的地方 国内很多人向往硅谷的一个原因是误以为在硅谷的工作时间短，同时还收入高。但事实却相反。在加州，很多科技公司的员工每周工作时间都远超 40 小时，甚至达到 100 小时都是很平常的事。在国内经常被人诟病的“996”工作制，每周的工作时间不过是 70 小时左右。即使是号称工作时间长的日本人，与硅谷的上班族相比都只是小巫见大巫，更何况在硅谷大家真的是有做不完的事，而不是干耗着不回家。这样算下来，硅谷人每小时的收入真不算高了。
除了工作时间长，硅谷人还面临着巨大的失业压力。在网络泡沫破碎后的两年，硅谷中心地区失业率高达 7%，全美国的平均失业率才 5%。很多被裁的人怕因为技术荒废而找不到工作，宁可不要工资工作。
在硅谷，如果一家公司不提供股票期权，就很难招到技术人员。这虽然看起来有点急功近利，但都是生活所迫。同时硅谷还是一个文化娱乐都相当匮乏的地方。
机会均等 在硅谷，个人的实际能力比所谓的名气、资历重要得多，要想成功，就要真刀真枪拿出真本事。所以那些初出茅庐肯实干的年轻人比经验丰富但眼高手低的权威更受公司青睐。甚至还会出现你的下属会在一两年后成为你的上级这种怪事。
硅谷很多风投机构都有一条投资原则，就是创业者一定要有饥渴感。
很难想象一个腰缠万贯的富翁会比一个急于脱离贫困现状的年轻人更有欲望把公司办好。前者办公司常常是为人生锦上添花，而后者则是破釜沉舟，没有退路的。这就是乔布斯勉励年轻人要保持饥渴感(Stay Hungry, Stay Foolish)的原因
​	&amp;mdash;&amp;mdash;《浪潮之巅 - 硅谷奇迹探秘》
除了科技行业，机会均等还体现在法律、金融、服务业等等各个行业。在硅谷，只要肯事干，就有机会成功。
因为机会多且均等，所以即使压力大，每年还是吸引着大量年轻的专业人士来到硅谷创业或者工作。
硅含量降低 硅谷最初以半导体产业闻名。但过去几十年间，硅谷已逐渐完成产业的升级转型，半导体产业在硅谷的经济中比重逐渐降低，取而代之的是互联网、软件、生物技术等高科技公司。反摩尔定律和“亚洲制造”是导致硅谷半导体产业衰落的两个直接原因。</description>
    </item>
    
    <item>
      <title>Centos 中缺少 CXXABI_1.3.8 的问题</title>
      <link>/posts/libstdcpp_error_in_centos/</link>
      <pubDate>Wed, 13 Jul 2022 16:29:30 +0800</pubDate>
      
      <guid>/posts/libstdcpp_error_in_centos/</guid>
      <description>最近在 Centos7.6 中利用 sequelize 连接 sqlite 的时候出现了如下错误：
/lib64/libstdc++.so.6: version `CXXABI_1.3.8&amp;#39; not found 出现这个错误是因为CentOS7当前版本默认的GCC的版本太老，里面的动态链接库没有CXXABI_1.3.8。
执行下面的命令可以看到没有找到 CXXABI_1.3.8：
strings /usr/lib64/libstdc++.so.6 | grep CXXABI 解决方案 cd /usr/local/lib64/ # 下载最新版本的`下载最新版本的libstdc.so_.6.0.26` wget http://www.vuln.cn/wp-content/uploads/2019/08/libstdc.so_.6.0.26.zip # 解压 unzip libstdc.so_.6.0.26.zip # 将下载的最新版本拷贝到 /usr/lib64 cp libstdc++.so.6.0.26 /usr/lib64 cd /usr/lib64 # 查看 /usr/lib64下libstdc++.so.6链接的版本 ls -l | grep libstdc++ # 删除原先的软连接(不放心可以备份) rm libstdc++.so.6 # 使用最新的库建立软连接 ln -s libstdc++.so.6.0.26 libstdc++.so.6 # 查看新版本，成功 strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX </description>
    </item>
    
    <item>
      <title>【How Vue Diff】之简单 Diff 算法</title>
      <link>/posts/how_vue_diff_simple_diff/</link>
      <pubDate>Wed, 06 Jul 2022 14:57:34 +0800</pubDate>
      
      <guid>/posts/how_vue_diff_simple_diff/</guid>
      <description>简单分析一下 Vuejs 中的“简单 Diff”算法，参考代码，主要关注 patchChildren() 函数的实现过程。
首先假设新旧 vnode 的子节点都是一组节点。因为如果其中一个 vnode 的子节点不是数组的话，Diff 的意义就不大了。
算法的整体流程 Diff 算法的主要目标是通过新旧两组节点的对比，找到可以复用的节点，然后移动节点到新的位置。所以，算法整体的流程总结一下就是：
找到可以复用的元素（即分别在新旧 children 中 key 相同的两个元素）； 对这两个节点进行 patch 操作； 移动元素到合适的位置； 处理新增或者不存在的元素； 找到可复用的元素 通过参考代码可以看到，算法的主要逻辑就是循环里嵌套循环：遍历新的子节点数组 newChildren，对于里面的每一个子节点 newVNode，都尝试在 oldChildren 中找到一个 oldVNode，使得 newVNode.key === oldVNode.key 即元素可复用。然后做一下更新，即 patch() 。
主体代码如下：
// 遍历新的 children for (let i = 0; i &amp;lt; newChildren.length; i++) { const newVNode = newChildren[i] let j = 0 // 遍历旧的 children for (j; j &amp;lt; oldChildren.length; j++) { const oldVNode = oldChildren[j] // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之 if (newVNode.</description>
    </item>
    
    <item>
      <title>如何选择用 Map 还是 Object</title>
      <link>/posts/map_or_object/</link>
      <pubDate>Wed, 29 Jun 2022 15:26:39 +0800</pubDate>
      
      <guid>/posts/map_or_object/</guid>
      <description>在很多场景里，我们似乎都可以用 Map 来代替 Object 来完成同样的功能，那么这两者到底要如何选择呢？这篇文章做了详细的描述和对比。
结论是：
如果在开发阶段就有固定且属性个数有限，可以使用 Object ，例如配置列表； 相反，如果 keys 的数量和类型不能提前知道，并且需要频繁更新的，就应该使用 Map ，例如 event emitter； 在插入、删除、遍历的时候，Map 的性能都比 Object 好，除非 keys 是比较小的整数。 </description>
    </item>
    
    <item>
      <title>Object.hasOwn vs Object.hasOwnProperty</title>
      <link>/posts/hasown_vs_hasownproperty/</link>
      <pubDate>Tue, 28 Jun 2022 15:00:11 +0800</pubDate>
      
      <guid>/posts/hasown_vs_hasownproperty/</guid>
      <description>Object.hasOwn() 是 ES2022 中的新特性，他它是一个静态方法，作用是提供一种安全的方法来检查某个对象是否自主拥有（不是继承而来的）某个属性。看起来作用跟 Object.hasOwnProperty() 一样，那为什么还要提出 Object.hasOwn() 呢？
原因有以下几个：
由于 Object.hasOwnProperty() 方法是从对象的原型 Object.prototype 上继承而来的，如果用户在对象上定义了一个同名的方法，就会出现意料之外的结果，即所谓的“原型污染”。 对于用 Object.create(null) 创建出来的对象，由于对象的原型就是 null ，所以对象本身没有 hasOwnProperty() 方法。虽然可以用 Object.prototype.hasOwnProperty.call() ，但是这样看起来就比较笨重了，并且 Eslint 的内置规则是禁止直接使用 Object.prototype 上的方法的。 Object.hasOwn() 就是为了解决上面的问题而提出的，所以应该用这个方法来代替 Object.hasOwnProperty()。
注意：不过需要注意的是，你依然可以重新定义 Object.hasOwn() 方法。</description>
    </item>
    
    <item>
      <title>移除项目中的 @ant-design/compatible 依赖</title>
      <link>/posts/remove-antd-compatible/</link>
      <pubDate>Tue, 21 Jun 2022 07:33:46 +0000</pubDate>
      
      <guid>/posts/remove-antd-compatible/</guid>
      <description>Ant Design 第4版发布之后不久，我就按照 antd 官方的指引利用迁移工具帮项目做了升级。由于迁移工具实际上是通过引入 @ant-design/compatible 来使那些不兼容的组件能继续运行，所以这样升级完之后实际上项目里就会同时存在 v3 和 v4 两个版本的 antd，不仅代码体积有冗余，还会有两套 Form 组件的写法，不利用后期维护。于是最近花时间移除了对 @ant-design/compatible 的依赖，实现了“完全”的升级。
这篇文章主要讲述我如何使用 AST 转换工具来帮助我完成升级。
修改范围与整体思路 需要做的迁移工作可以参考 antd 官方的说明。
对于我的项目，由于使用到 @ant-design/compatible 的基本上只有 v3 版本的 Form 组件， 所以要修改的范围主要有这些：
移除 Form.create({})(Component) 写法； 把 getFieldDecorator 的写法改成用 &amp;lt;Form.Item&amp;gt;； 移除 @ant-design/compatible 相关的 import 语句； 修改表单实体方法的调用方式。 第 1 点基本上可以通过编辑器的字符串替换功能加上正则表达式完成。
第 2、3 点可以我用一个 AST 转换工具来辅助修改。这是本文的重点，后面会展开说。
第 4 点理论上也可以用刚刚提到的工具来修改，但是项目里调用的方法不统一，例如有 this.props.form.setFieldsValue 也有 const { setFieldsValue } from this.props.form 等等，工具里需要的判断比较多。而且项目里使用到的实体方法不算很多，修改起来工作量比 getFieldDecorator 少很多。所以我打算手动修改，刚好可以边自测边修改。
确认范围之后就可以开干了。
代码修改工具 下面主要说说上面提到的 “代码修改工具”。</description>
    </item>
    
    <item>
      <title>一个基于 Systemjs 的组件动态加载方案</title>
      <link>/posts/loading_compoents_dynamically_by_systemjs/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/loading_compoents_dynamically_by_systemjs/</guid>
      <description>背景 在低代码平台的设计中，通常需要动态地加载一个组件。
Bigo 的活动配置平台 raptor 使用 requirejs 来实现动态加载。requirejs 要求加载的是 AMD 格式的包。但是很多优秀的第三方组件都没有打包成 AMD 格式，而是只有Commonjs 和 ESM 版本，这就意味着不能直接在平台里使用这些组件。
为了解决上述问题，可以使用 systemjs。利用 systemjs ，可以通过动态加载的方式加载一个远程的 ESM 模块，并且运行在不支持 ESM 格式的浏览器中。
Systemjs systemjs 实现了一个叫做 System.register 的模块格式，用于在浏览器中实现动态 import()、import.meta (包括 import.meta.url and import.meta.resolve) 等功能。更多的功能请参考 systemjs 的文档。
例如以下例子：
使用 使用的时候，需要提前添加以下 script 标签：
&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/systemjs/dist/system.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;systemjs-importmap&amp;#34;&amp;gt; // 定义 importmap { &amp;#34;imports&amp;#34;: { &amp;#34;lodash&amp;#34;: &amp;#34;https://unpkg.com/lodash@4.17.10/lodash.js&amp;#34; // 或者其他需要动态加载的模块 } } &amp;lt;/script&amp;gt; 接着，就可以使用以下两种方法来加载并使用一个在上面的 importmap 中配置过的模块。
window.System.import // window.System.import 返回的是一个 Promise 对象 window.System.import(&amp;#39;lodash&amp;#39;) .then(lodash =&amp;gt; lodash.</description>
    </item>
    
    <item>
      <title>在 web 环境中获取 uuid 的简单方法</title>
      <link>/posts/web-create-uuid/</link>
      <pubDate>Wed, 15 Dec 2021 10:10:51 +0800</pubDate>
      
      <guid>/posts/web-create-uuid/</guid>
      <description>偶然在掘金看到了一个在 web 环境中生成 uuid 的方法，只需要一行代码。来自这篇文章的评论区。
URL.createObjectURL(new Blob()).substr(-36); 解析 下面稍微解析一下这行代码。
URL.createObjectURL() 接收一个类型是 File, Blob, 或者 MediaSource 的对象作为参数，然后返回一个 DOMString。这个 DOMString 指向作为参数传入的对象。然后就可以通过这个 DOMString 访问到对应的对象。
即使传入的是同一个对象，每次调用 URL.createObjectURL() 都会返回一个新的 DOMString 。留意返回的 DOMString，会发现最后的 36 个字符是一串唯一的字符串，用来区分每个 DOMString 。例如：
&amp;#39;blob:https://www.google.com/82482eae-c186-4246-b02b-40d43d9f4d90&amp;#39; 所以截取最后的 36 个字符后就能获得一个 uuid。对于一般的 web 应用来说，这个方法比引入一个 UUID 或 NanoId 库更简单。
另外，在 MDN 的文档里也提到了，虽然浏览器会在页面 unloaded 的时候自动释放由 URL.createObjectURL() 创建的 object URL，但如果你对性能和内存使用有要求的话，最好还是手动调用一下 URL.revokeObjectURL() 来释放 object URL。
参考 createObjectURL DOMString </description>
    </item>
    
    <item>
      <title>获取一行中子元素的个数</title>
      <link>/posts/children_count_in_one_row/</link>
      <pubDate>Mon, 25 Oct 2021 19:15:32 +0800</pubDate>
      
      <guid>/posts/children_count_in_one_row/</guid>
      <description>有这样一个场景：一个父元素中有若干个行内子元素，子元素数量比较多，需要换行展示。例如下图。此时我想知道每一行里有多少个子元素，要怎么做？
如果每个子元素的宽度都是固定，那就直接用父元素的宽度除以子元素的宽度就可以。但如果每个子元素的宽度不固定呢？
对于子元素宽度不固定的情况，关键是要找到从哪个元素开始换行。以下是两种思路：
遍历每个子元素，并且对每个子元素的宽度做累加，如果累加的宽度超过了父元素的宽度，就表示需要换行； 还是遍历子元素，然后获取每个子元素距离父元素左边或者屏幕左边的距离，假设是 X，如果子元素是在同一行，X 就会逐渐增加。如果在遍历的过程中出现了一个元素，它的 X 与第 0 个元素的 X 一样，或者简单点，比上一个元素的 X 小，就表示发生了换行。 </description>
    </item>
    
    <item>
      <title>入坑客制化键盘的一些建议</title>
      <link>/posts/custom_keyboard_attention/</link>
      <pubDate>Sat, 16 Oct 2021 11:48:50 +0800</pubDate>
      
      <guid>/posts/custom_keyboard_attention/</guid>
      <description>进入客制化键盘圈子有一段时间了，我发现这个圈子虽然相对小众，但是不乏优秀的作品。不过跟其他圈子一样，新入门的时候很容易走弯路，花钱买了自己不喜欢或者不合适的东西，最后只能搁置或者亏钱转卖。于是我总结了一下这段时间里自己的体会，希望能帮助客制化键盘的新手们少走一些弯路，多省点钱。
在哪里获取新动态 首先说说在哪里能了解到最新的客制化键盘相关的资讯。
装备前线 我最常去的是 zFrontier 装备前线 的「机械键盘」板块。这里是我知道的国内最活跃的客制化键盘论坛了。里面还有 pc 装机、摄影、模型等等的其他板块，但我基本只看键盘相关的。
里面除了会有键圈的朋友们晒自己的装备，还会有键盘相关产品的作者发布最新的产品消息等等。通过某些贴子里网友们的讨论，还能学到很多客制化键盘相关的知识。有空逛一逛，就能在短时间内了解到很多键圈最新的动态。
各种聊天群 如果想要在第一时间了解到最新的产品消息，应该就要加入各种聊天群了，通常是 QQ 群。群号能在装备前线的一些贴子里找到，如果是新产品的贴子，一般能在贴子顶部找到；有时候还能在底下的评论里找到。
这些群通常是某个新产品的作者建立的，用来沟通新产品的各种细节，包括前期的设计、购买渠道/时间、发货时间、售后情况等等。很多时候还会发布下一个新产品的信息。
B站 在 BiliBili 除了有键盘的评测，还会有一些键圈信息的汇总。比较知名的有键盘侠赤瞳妖，KeyboardDaily，Ayb爱莹宝 等等。
购买方式 团购 新发布的套件、键帽等通常是限量团购的形式，比较少有现货。
团购多数是先款团购，也就是先付款（全款和定金都有）再生产，然后再发货，而且生产时间通常都比较久，有些人可能收到货的时候才想起来自己曾经下单买过。如果是套件的话一般都要两三个月。键帽可能会快一点，一个月左右，但也有例外，说的就是 GMK。现在（2021年10月）下单，都要等到 2023 年第一季度才能发货，中间还有可能会因为客观因素而导致延期或流产。除了客观因素，还可能在等待期间你就喜欢上了别的套件/键帽甚至退坑了。但多数时候上了团购的车就不能退款了，只能自己想办法转单，装备前线里就有很多键帽转单的。
其实这个过程跟「期货」有点像，都是花钱买未来的产品。
你可能会觉得这种形式有点坑，中间的变数太多。但实际上很多套件/键帽的作者都是个人或者小团队，没有自己的生产设备，只能找代工厂。而工厂都是要先付一部分钱才能生产，但小团队通常也没有这么多的资金，所以只能先款团购，这也无可厚非。如果你实在不放心，可以看看以下其他的购买方式。
现货 有些产品如果在前期的设计阶段（或者叫 IC，Interest Check）已经有比较好的反响，有购买意愿的人数比较多，就会在团购订单之外额外多生产一些，用作现货售卖。当然数量不会很多而且价钱会比团购贵一点。好处就是不用等太久，而且能看看前期团购用户的真是反馈再决定买不买。
还有一些一开始是限量团购，发货后发现用户反馈比较热烈，就会再生产一批现货出售。像我之前买的一套 2021 流行色键帽就是团购结束后再放出现货，团购的时候我还没入坑客制化，所以是在现货阶段买的。
在哪里买 对于新出的产品，如果你能了解到有这款产品，一般也就能知道在哪里买。因为发布新产品的贴子里通常都会有注明购买渠道，这些渠道一般包括作者自己的网站或小程序、淘宝店、还有第三方的代理商，例如装备前线、KBDFans、米可维外设等等，还会有一些国外的网站。
如果是已经截团的产品，可以先到闲鱼找找，除了二手有时候还能找到全新未拆封的。因为有些人专门做这种倒卖，或者单纯只是因为收到货后就不想要了。
不过要注意在闲鱼里很多时候都会有一定程度的溢价，不要看到喜欢的就直接买。最好先尽可能找找这个套件/键帽相关的资料，包括开团价、配置里具体有哪些东西、各类评测，再看看网友们的晒图，看看自己是不是真的喜欢，溢价是否合理或者自己能否承受得了。除非你不在乎钱，否则我还是建议你先考虑清楚再买。
套件 配列 如果要买套件，我首先会考虑的是配列。关于配列，可以参考一下这里客制化键盘配列 - by ^elvis^ - 来自 zFrontier.com。
在考虑配列的时候，我一般会从实用性和占用空间两方面考虑。
对于大尺寸的配列，虽然功能区和数字键都有，但你可能极少会用到。没必要为了这些不经常用到的功能而占用过多的桌面空间，除非你就是喜欢它的外观。还有一点就是多了一个数字键盘，就会使得字母区和鼠标之间的距离变长，继而导致右手在字母区与鼠标之间切换的距离变长，导致右手更容易累。当然更极致一点的就是完全用键盘组合键来代替鼠标操作。还有一些奇怪的配列会把字母区或者 F 区放在键盘左侧。
对于小尺寸配列，要小心不要被它小巧精致的外观而迷惑。首先要考虑一下有哪些功能键是你比较依赖的，如果配列里没有，你是否能接受通过组合键来触发。其次还要考虑一下键盘尺寸变小之后带来的输入习惯的变化。比较明显的就是方向键的位置变化，有可能变成与其他按钮放在一起而导致容易误触，以及左移 64 配列里右 shift 键变小的问题。
我之前也曾经有过一把左移 64 的 prism60，类似于下图，这是来自“装备前线 键盘葫芦forkrere60 by elvis”的照片。
虽然它能基本满足我日常工作需求，但是右 shift 键只有 1U 宽度，并且与方向键挨在一起，导致很容易误触，很不爽。所以最后我还是放弃了它。</description>
    </item>
    
  </channel>
</rss>
