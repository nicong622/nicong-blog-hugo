<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Nicong&#39;s blog</title>
		<link>/posts/</link>
		<description>Recent content in Posts on Nicong&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 10 Sep 2021 18:25:55 +0800</lastBuildDate>
		<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Webify &#43; Hugo 搭建个人博客</title>
			<link>/posts/webify_hugo/</link>
			<pubDate>Fri, 10 Sep 2021 18:25:55 +0800</pubDate>
			
			<guid>/posts/webify_hugo/</guid>
			<description>一些废话 以前试过用不同方案搞过自己的博客，最开始是直接用 GitHub Pages。后来趁着活动买过腾讯云的服务器，然后分别用 Hexo 和 Gatsby 在上面搭建过博客。一开始只是为了想了解一下如何搭建一个个人网站，同时有个看起来比较有个性的地方来放自己的笔记或技术文章（虽然一年也写不了几篇）。并且一开始学前端开发的时候总觉得个人网站是一个前端开发者的标配。
后来也是因为各种原因（主要是懒）没有坚持更新，甚至买来的服务器一年也没登录过几次，一直到过期了就没再续费。所以虽然已经工作了几年，bug 写了不少，但博客文章却没写过几篇。
前段时间在朋友圈看到有人转发有关腾讯云开发 Webify 的介绍文章，感觉使用起来还挺方便的，而且是免费，那就去搞个博客吧，反正以前的访问不了了，万一以后找工作面试官问起的时候，你说没有博客那就尴尬了。
技术方案 应用托管的话就是用 Webify，还差一个博客系统。现在常用的应该就几个：Hexo、Gatsby、Hugo、Vuepress。
 Hexo 几年前用过，感觉还不错，但是不知道现在还有没有再维护； Gatsby 稍微用过一下，感觉功能还是挺全面的，用来做这种小型的个人博客可以说是卓卓有余，甚至有点大材小用了； Vuepress 我没用过，貌似相对小众一点，而且能用的主题貌似也不多； Hugo 貌似已经发布有一段时间了，也是没有用过，不过之前在 v2ex 看到有人推荐。大概看了一下上手还挺简单，而且找到了自己一个喜欢的免费主题（这是重点）。那就决定是你了，Hugo！  于是，大致的技术方案就是 Webify 负责应用托管，Hugo 负责生成静态文件。OK，开搞。
网站搭建 大致浏览一下 Webify 的文档 ，发现需要我们的静态文件不能直接部署到 Webify，而是要先把静态文件推送到自己的代码托管平台，然后 Webify 去你的代码托管平台拉取文件，并部署到 CDN。
大概原来就是在 Webify 上新建项目的时候需要你授权去关联代码托管平台上的某个项目（或者新建一个项目），然后在这个项目里添加一个 webhook，当在特定分支（默认是 master）触发了特定事件（默认是 push），Webify 就会去拉取项目的最新文件并且部署。
Webify 和 Hugo 的 quickstart 文档都有，没什么好说的。</description>
			<content type="html"><![CDATA[<h2 id="一些废话">一些废话</h2>
<p>以前试过用不同方案搞过自己的博客，最开始是直接用 <a href="https://pages.github.com/">GitHub Pages</a>。后来趁着活动买过腾讯云的服务器，然后分别用 <a href="https://hexo.io/">Hexo</a> 和 <a href="https://www.gatsbyjs.com/">Gatsby</a> 在上面搭建过博客。一开始只是为了想了解一下如何搭建一个个人网站，同时有个看起来比较有个性的地方来放自己的笔记或技术文章（虽然一年也写不了几篇）。并且一开始学前端开发的时候总觉得个人网站是一个前端开发者的标配。</p>
<p>后来也是因为各种原因（主要是懒）没有坚持更新，甚至买来的服务器一年也没登录过几次，一直到过期了就没再续费。所以虽然已经工作了几年，bug 写了不少，但博客文章却没写过几篇。</p>
<p>前段时间在朋友圈看到有人转发有关腾讯云开发 <a href="https://webify.cloudbase.net/">Webify</a> 的介绍文章，感觉使用起来还挺方便的，而且是免费，那就去搞个博客吧，反正以前的访问不了了，万一以后找工作面试官问起的时候，你说没有博客那就尴尬了。</p>
<h2 id="技术方案">技术方案</h2>
<p>应用托管的话就是用 Webify，还差一个博客系统。现在常用的应该就几个：Hexo、Gatsby、Hugo、Vuepress。</p>
<ol>
<li>Hexo 几年前用过，感觉还不错，但是不知道现在还有没有再维护；</li>
<li>Gatsby 稍微用过一下，感觉功能还是挺全面的，用来做这种小型的个人博客可以说是卓卓有余，甚至有点大材小用了；</li>
<li>Vuepress 我没用过，貌似相对小众一点，而且能用的主题貌似也不多；</li>
<li>Hugo 貌似已经发布有一段时间了，也是没有用过，不过之前在 v2ex 看到有人推荐。大概看了一下上手还挺简单，而且找到了自己一个喜欢的免费主题（这是重点）。那就决定是你了，Hugo！</li>
</ol>
<p>于是，大致的技术方案就是 Webify 负责应用托管，Hugo 负责生成静态文件。OK，开搞。</p>
<h2 id="网站搭建">网站搭建</h2>
<p>大致浏览一下 <a href="https://webify.cloudbase.net/">Webify 的文档</a> ，发现需要我们的静态文件不能直接部署到 Webify，而是要先把静态文件推送到自己的代码托管平台，然后 Webify 去你的代码托管平台拉取文件，并部署到 CDN。</p>
<p>大概原来就是在 Webify 上新建项目的时候需要你授权去关联代码托管平台上的某个项目（或者新建一个项目），然后在这个项目里添加一个 webhook，当在特定分支（默认是 master）触发了特定事件（默认是 push），Webify 就会去拉取项目的最新文件并且部署。</p>
<p>Webify 和 Hugo 的 quickstart 文档都有，没什么好说的。</p>
]]></content>
		</item>
		
		<item>
			<title>nuxt-link预加载的原理</title>
			<link>/posts/how-do-nuxt-link-preload/</link>
			<pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate>
			
			<guid>/posts/how-do-nuxt-link-preload/</guid>
			<description>nuxt-link 是 nuxtjs 提供的一个组件，基于 vue-router 的 router-link 做了一层封装，实现了预加载的功能。本文来简单聊聊这个“预加载”的原理。
一点准备工作 如果直接打开 nuxt 项目中 nuxt-link的源码，会发现里面使用了很多类似于 &amp;lt;%...%&amp;gt; 这样的模板语法。这其实是 lodash.template 提供的模板语法。如果觉得影响阅读，可以按照 nuxt 的文档，新建一个 nuxt 应用，然后构建一次，再找到 .nuxt/components/nuxt-link.client.js，这个就是编译过后的 nuxt-link 代码。
前置条件 要想触发 nuxt-link 的预加载，需要同时满足以下几个条件：
  nuxt-link 的 prefetch 属性值是 true 。
默认值是 nuxt 配置里的 router.prefetchLinks。prefetchLinks 的默认值是 true ，所以 prefetch 的默认值也是 true。
  nuxt-link 的 noPrefetch 属性值是 false。默认值是 false。
  当 nuxt-link 组件出现在可见区域内。
  nuxt-link 的 to 属性指向的页面是同一个应用的页面。
  有网络链接并且不是 2g 网络。</description>
			<content type="html"><![CDATA[<p><code>nuxt-link</code> 是 <a href="https://nuxtjs.org/">nuxtjs</a> 提供的一个组件，基于 <a href="https://router.vuejs.org/">vue-router</a> 的 <code>router-link</code> 做了一层封装，实现了<a href="https://nuxtjs.org/blog/introducing-smart-prefetching#introducing-smart-prefetching-%EF%B8%8F">预加载</a>的功能。本文来简单聊聊这个“预加载”的原理。</p>
<h2 id="一点准备工作">一点准备工作</h2>
<p>如果直接打开 <code>nuxt</code> 项目中 <a href="https://github.com/nuxt/nuxt.js/blob/dev/packages/vue-app/template/components/nuxt-link.client.js">nuxt-link的源码</a>，会发现里面使用了很多类似于 <code>&lt;%...%&gt;</code> 这样的模板语法。这其实是 <a href="https://lodash.com/docs/4.17.15#template">lodash.template</a> 提供的模板语法。如果觉得影响阅读，可以按照 <code>nuxt</code> 的文档，新建一个 nuxt 应用，然后构建一次，再找到 <code>.nuxt/components/nuxt-link.client.js</code>，这个就是编译过后的 <code>nuxt-link</code> 代码。</p>
<h2 id="前置条件">前置条件</h2>
<p>要想触发 <code>nuxt-link</code> 的预加载，需要同时满足以下几个条件：</p>
<ol>
<li>
<p><code>nuxt-link</code> 的 <code>prefetch</code> 属性值是 <code>true</code> 。</p>
<p>默认值是 nuxt 配置里的 <code>router.prefetchLinks</code>。<code>prefetchLinks</code> 的默认值是 <code>true</code> ，所以 <code>prefetch</code> 的默认值也是 <code>true</code>。</p>
</li>
<li>
<p><code>nuxt-link</code> 的 <code>noPrefetch</code> 属性值是 <code>false</code>。默认值是 <code>false</code>。</p>
</li>
<li>
<p>当 <code>nuxt-link</code> 组件出现在可见区域内。</p>
</li>
<li>
<p><code>nuxt-link</code> 的 <code>to</code>  属性指向的页面是同一个应用的页面。</p>
</li>
<li>
<p>有网络链接并且不是 <code>2g</code> 网络。</p>
</li>
</ol>
<p>1、2 两点控制是否启动预加载功能（默认是开启预加载），3、4、5是决定什么时候执行预加载的逻辑。</p>
<h2 id="原理">原理</h2>
<p>接下来梳理一下预加载的大致流程。为了说明原理，<code>nuxt-link</code> 源码里有些条件分支会省略，但不影响理解。下面会以 <code>/cart</code> 这个链接作为 <code>nuxt-link</code> 的跳转地址来做说明。<code>/cart</code> 页面对应的文件路径是 <code>/pages/cart/index.vue</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">nuxt-link</span> <span class="na">to</span><span class="o">=</span><span class="s">&#34;/cart&#34;</span><span class="p">&gt;</span>购物车<span class="p">&lt;/</span><span class="nt">nuxt-link</span><span class="p">&gt;</span>
</code></pre></div><h3 id="事件监听">事件监听</h3>
<p>在 <code>nuxt-link</code> 的 <code>mounted</code> 阶段，如果设置了开启预加载，即 <code>this.prefetch &amp;&amp; !this.noPrefetch</code>，就会开始监听 <code>nuxt-link</code> 元素是否进入了可视区域。</p>
<p>当元素进入了可视区域，就会调用 <code>prefetchLink</code> 方法进行预加载。</p>
<p>监听过程中使用了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">window.requestIdleCallback</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">window.IntersectionObserver</a> 这两个 API。</p>
<h3 id="预加载">预加载</h3>
<p>核心的逻辑在 <code>prefetchLink()</code> 函数里：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">prefetchLink</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">canPrefetch</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="c1">// Stop observing this link (in case of internet connection changes)
</span><span class="c1"></span>  <span class="nx">observer</span><span class="p">.</span><span class="nx">unobserve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$el</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">Components</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getPrefetchComponents</span><span class="p">()</span>

  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">Component</span> <span class="k">of</span> <span class="nx">Components</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">componentOrPromise</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">componentOrPromise</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">componentOrPromise</span><span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{})</span>
    <span class="p">}</span>
    <span class="nx">Component</span><span class="p">.</span><span class="mi">__</span><span class="nx">prefetched</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>首先要获取需要预加载的组件。</p>
<p>在 <code>getPrefetchComponents()</code> 方法里，使用了 <code>vue-router</code> 的 <code>router.resolve</code> 方法，找到将要跳转的页面对应的页面入口，即 <code>Components</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">getPrefetchComponents</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$router</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">to</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">$route</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">append</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">Components</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">resolved</span><span class="p">.</span><span class="nx">matched</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">r</span> <span class="p">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">components</span><span class="p">.</span><span class="k">default</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">Components</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">Component</span> <span class="p">=&gt;</span> <span class="k">typeof</span> <span class="nx">Component</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">Component</span><span class="p">.</span><span class="nx">options</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">Component</span><span class="p">.</span><span class="mi">__</span><span class="nx">prefetched</span><span class="p">)</span>
<span class="p">},</span>
</code></pre></div><p>在浏览器开发工具里打印一下 <code>Components</code>，看到以下信息：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc70c999a4f45e98e4f5b30e4dca864~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<p>可以看到 <code>Components</code> 里的每个元素都是一个函数，点击 <code>[[FunctionLocation]]</code> 的值，<code>router.js</code>，可以跳到函数定义的位置。然后你就会发现打开的这个 <code>router.js</code> 其实就是我们的项目构建完之后得到的 <code>.nuxt/router.js</code> 。</p>
<p>通过 <code>_30f4c240()</code>  这个函数的定义可以发现它的核心功能其实就是引入了 <code>/cart</code> 对应的页面文件。如果调用这个方法，就会在浏览器开发者工具的 network 面板看到浏览器请求了 <code>/_nuxt/pages/cart/index.js</code> 这个文件，即加载了 <code>/cart</code>  这个页面对应的代码。具体的加载过程属于 <code>webpack</code> 的功能，这里不做说明。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// .nuxt/router.js
</span><span class="c1"></span><span class="kr">const</span> <span class="mi">_30</span><span class="nx">f4c240</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">interopDefault</span><span class="p">(</span><span class="kr">import</span><span class="p">(</span><span class="s1">&#39;../src/pages/cart/index.vue&#39;</span> <span class="cm">/* webpackChunkName: &#34;pages/cart/index&#34; */</span><span class="p">))</span>
</code></pre></div><p>在获取到上面的加载函数之后，<code>prefetchLink</code> 就会调用这些函数，达到预加载的效果。之后，还会设置一个 <code>__prefetch</code> 的标识，防止重复加载。</p>
<p>以上就是 <code>nuxt-link</code> 预加载的大致过程。</p>
<h2 id="延伸">延伸</h2>
<p>在 <code>nuxt-link</code> 的源码里，还能找到一些有趣的点：</p>
<h3 id="自定义预加载">自定义预加载</h3>
<p>有些时候我们没有使用 <code>nuxt-link</code> 来做页面跳转，但又想预加载这个页面，就可以这样做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">myPrefetch</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$router</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">$route</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">Components</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">resolved</span><span class="p">.</span><span class="nx">matched</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">components</span><span class="p">.</span><span class="k">default</span><span class="p">);</span>

  <span class="nx">Components</span>
    <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">Component</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">typeof</span> <span class="nx">Component</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">Component</span><span class="p">.</span><span class="nx">options</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">Component</span><span class="p">.</span><span class="mi">__</span><span class="nx">prefetched</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">Component</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">componentOrPromise</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">componentOrPromise</span> <span class="k">instanceof</span> <span class="nb">Promise</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">componentOrPromise</span><span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{});</span>
      <span class="p">}</span>
      <span class="nx">Component</span><span class="p">.</span><span class="mi">__</span><span class="nx">prefetched</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">},</span>
</code></pre></div><p>可以使用以下方法简化一下 <code>Components</code> 的获取：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">Components</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$router</span><span class="p">.</span><span class="nx">getMatchedComponents</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
</code></pre></div><h3 id="navigatorconnection">navigator.connection</h3>
<p>可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection">navigator.connection</a> 来判断网络状态，但是要注意兼容性。</p>
<h3 id="quicklink">quicklink</h3>
<p>在 <code>react</code> 项目里，可以使用 <a href="https://github.com/GoogleChromeLabs/quicklink">quicklink</a> 实现预加载的功能。</p>
]]></content>
		</item>
		
		<item>
			<title>Textarea 自适应高度</title>
			<link>/posts/autosize_textarea_height/</link>
			<pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate>
			
			<guid>/posts/autosize_textarea_height/</guid>
			<description>如何使 textarea 元素的高度可以根据内容自动伸缩？
只需两行代码：
// 当输入的时候 textarea.style.height = &amp;#39;auto&amp;#39;; textarea.style.height = textarea.scrollHeight + &amp;#39;px&amp;#39;; 第一行的作用是在删除输入的内容时候让 textarea 的高度能自动缩回去；
在 Vue 中使用：https://codepen.io/Nicong622/pen/LYZYNqb</description>
			<content type="html"><![CDATA[<p>如何使 <em>textarea</em> 元素的高度可以根据内容自动伸缩？</p>
<p>只需两行代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 当输入的时候
</span><span class="c1"></span><span class="nx">textarea</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">;</span>
<span class="nx">textarea</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">textarea</span><span class="p">.</span><span class="nx">scrollHeight</span> <span class="o">+</span> <span class="s1">&#39;px&#39;</span><span class="p">;</span>
</code></pre></div><p>第一行的作用是在删除输入的内容时候让 <em>textarea</em> 的高度能自动缩回去；</p>
<p>在 Vue 中使用：https://codepen.io/Nicong622/pen/LYZYNqb</p>
]]></content>
		</item>
		
		<item>
			<title>Vue Devtool Panel not Showing</title>
			<link>/posts/vue_devtool_panel_not_showing/</link>
			<pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate>
			
			<guid>/posts/vue_devtool_panel_not_showing/</guid>
			<description>Chrome 的 vue devtool 插件已经检测到当前页面使用了 Vue ，但是 Chrome 开发者工具里没有出现 Vue devtool panel，要怎么处理？
第一步 首先检查一下项目里是否手动设置了 Vue.config.devtools 。把这个配置设为 true 的时候就能看到 Vue devtool panel 。这个配置需要在创建 Vue 实例之前。根据 Vue官方文档 的说法，Vue.config.devtools 在开发时候默认是 true 。
设置完之后重新构建一次，然后重新打开 Chrome devtool 或者修改 Chrome devtool 的主题，就能看到 Vue devtool。
多数情况下这一步就能解决问题。
第二步 如果上一步还是不能解决问题，再试试在创建了 Vue 实例之后执行 window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue = app.constructor; 其中 app 是 Vue 的实例。
或者直接在 Chrome devtool 里执行 window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue = Vue;。
参考 https://github.com/vuejs/vue-devtools/issues/620#issuecomment-368948291</description>
			<content type="html"><![CDATA[<p>Chrome 的 vue devtool 插件已经检测到当前页面使用了 Vue ，但是 Chrome 开发者工具里没有出现 Vue devtool panel，要怎么处理？</p>
<h2 id="第一步">第一步</h2>
<p>首先检查一下项目里是否手动设置了 <code>Vue.config.devtools</code> 。把这个配置设为 <code>true</code> 的时候就能看到 Vue devtool panel 。这个配置需要在创建 Vue 实例之前。根据 <a href="https://vuejs.org/v2/api/#devtools">Vue官方文档</a> 的说法，<code>Vue.config.devtools</code> 在开发时候默认是 <code>true</code> 。</p>
<p>设置完之后重新构建一次，然后重新打开 Chrome devtool 或者修改 Chrome devtool 的主题，就能看到 Vue devtool。</p>
<p>多数情况下这一步就能解决问题。</p>
<h2 id="第二步">第二步</h2>
<p>如果上一步还是不能解决问题，再试试在创建了 Vue 实例之后执行 <code>window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue = app.constructor;</code> 其中 app 是 Vue 的实例。</p>
<p>或者直接在 Chrome devtool 里执行 <code>window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue = Vue;</code>。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/vuejs/vue-devtools/issues/620#issuecomment-368948291">https://github.com/vuejs/vue-devtools/issues/620#issuecomment-368948291</a></p>
]]></content>
		</item>
		
		<item>
			<title>如何让 VScode 识别到你的 alias</title>
			<link>/posts/letting_vscode_konw_your_alias/</link>
			<pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate>
			
			<guid>/posts/letting_vscode_konw_your_alias/</guid>
			<description>假设有这样一个 alias：
alias: { &amp;#39;@&amp;#39;: &amp;#39;./src&amp;#39; } tsconfig.json tsconfig.json 或者 jsconfig.json 中加入以下配置：
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;baseUrl&amp;#34;: &amp;#34;.&amp;#34;, &amp;#34;paths&amp;#34;: { &amp;#34;@/*&amp;#34;: [&amp;#34;./src/*&amp;#34;] } } } 这时候 vscode 就能识别到你的 alias ，也就是可以在输入路径的时候出现提示
eslint 如果你有用 eslint ，即使 vscode 已经识别出来你的 alias，但 eslint 依然有可能会报 “找不到模块” 的错误。这时候可以使用这个模块 eslint-import-resolver-webpack 。就可以去掉 eslint 的报错</description>
			<content type="html"><![CDATA[<p>假设有这样一个 alias：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">alias</span><span class="o">:</span> <span class="p">{</span>
  <span class="s1">&#39;@&#39;</span><span class="o">:</span> <span class="s1">&#39;./src&#39;</span>
<span class="p">}</span>
</code></pre></div><h2 id="tsconfigjson">tsconfig.json</h2>
<p><code>tsconfig.json</code> 或者 <code>jsconfig.json</code> 中加入以下配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;compilerOptions&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;baseUrl&#34;</span><span class="p">:</span> <span class="s2">&#34;.&#34;</span><span class="p">,</span>
    <span class="nt">&#34;paths&#34;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&#34;@/*&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;./src/*&#34;</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这时候 vscode 就能识别到你的 alias ，也就是可以在输入路径的时候出现提示</p>
<h2 id="eslint">eslint</h2>
<p>如果你有用 eslint ，即使 vscode 已经识别出来你的 alias，但 eslint 依然有可能会报 “找不到模块” 的错误。这时候可以使用这个模块 <a href="https://www.npmjs.com/package/eslint-import-resolver-webpack">eslint-import-resolver-webpack</a> 。就可以去掉 eslint 的报错</p>
]]></content>
		</item>
		
	</channel>
</rss>
